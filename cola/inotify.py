# Copyright (c) 2008 David Aguilar
"""This module provides an inotify plugin for Linux and other systems
which provide the pyinotify module.

"""

import os
import time
from PyQt4.QtCore import QCoreApplication
from PyQt4.QtCore import QThread
from PyQt4.QtCore import QEvent
from PyQt4.QtCore import SIGNAL

try:
    import pyinotify
    from pyinotify import ProcessEvent
    from pyinotify import WatchManager
    from pyinotify import Notifier
    from pyinotify import EventsCodes
    AVAILABLE = True
except ImportError:
    ProcessEvent = object
    AVAILABLE = False
    pass

INOTIFY_EVENT = QEvent.User + 0

class FileSysEvent(ProcessEvent):
    """FileSysEvents are generated by the GitNotifier thread
    and represent the inotify events.
    """
    def __init__(self, parent):
        """FileSysEvent keeps a reference to the Qt parent and remembers
        the last event time to avoid event floods.
        """
        self.last_event_time = time.time()
        ProcessEvent.__init__(self)
        self.parent = parent
    def process_default(self, event):
        """Notifies the Qt parent when actions occur."""
        # Prevent notificaiton floods
        if time.time() - self.last_event_time > 1.0:
            self.parent.notify()
        self.last_event_time = time.time()

class GitNotifier(QThread):
    """This polls inotify for changes and generates FileSysEvents
    in response to updates.
    """
    def __init__(self, receiver, git, timeout=250):
        QThread.__init__(self)
        self.receiver = receiver #: The Qt receiver of the event
        self.git = git #: git command object
        self.timeout = timeout #: used by pyinotify
        self.path = git.get_work_tree() #: Path to monitor
        self.abort = False #: Whether to abort (using during destruction)
        self.dirs_seen = set() #: Directories we're watching
        #: Events we capture
        self.mask = (EventsCodes.ALL_FLAGS['IN_CREATE'] |
                     EventsCodes.ALL_FLAGS['IN_DELETE'] |
                     EventsCodes.ALL_FLAGS['IN_MODIFY'] |
                     EventsCodes.ALL_FLAGS['IN_MOVED_TO'])

    def notify(self):
        """Posts a Qt event in response to inotify updates.
        """
        if not self.abort:
            event_type = QEvent.Type(INOTIFY_EVENT)
            event = QEvent(event_type)
            QCoreApplication.postEvent(self.receiver, event)

    def watch_directory(self, directory):
        """Sets up a directory for monitoring by inotify.
        """
        directory = os.path.realpath(directory)
        if directory not in self.dirs_seen:
            self.wm.add_watch(directory, self.mask)
            self.dirs_seen.add(directory)

    def _is_pyinotify_08x(self):
        """The pyinotify API changed between 0.7.x and 0.8.x.
        This allows us to maintain backwards compatibility.
        """
        if hasattr(pyinotify, '__version__'):
            if pyinotify.__version__[:3] == '0.8':
                return True
        return False

    def run(self):
        """This creates the inotify WatchManager and generates
        FileSysEvents."""
        # Only capture those events that git cares about
        self.wm = WatchManager()
        if self._is_pyinotify_08x():
            notifier = Notifier(self.wm, FileSysEvent(self), timeout=self.timeout)
        else:
            notifier = Notifier(self.wm, FileSysEvent(self))
        dirs_seen = set()
        added_flag = False
        # self.abort signals app termination.  The timeout is a tradeoff
        # between fast notification response and waiting too long to exit.
        while not self.abort:
            if not added_flag:
                self.watch_directory(self.path)
                # Register files/directories known to git
                for file in self.git.ls_files().splitlines():
                    directory = os.path.dirname(file)
                    self.watch_directory(directory)
                added_flag = True
            notifier.process_events()
            if self._is_pyinotify_08x():
                check = notifier.check_events()
            else:
                check = notifier.check_events(timeout=self.timeout)
            if check:
                notifier.read_events()
        notifier.stop()
