#!/usr/bin/env python
"""Replace hard-coded version strings with an updated version"""
import argparse
import datetime
import os
import sys


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser()
    parser.add_argument('version')
    args = parser.parse_args()
    version = args.version

    # Old workflow: move relnotes/unreleased.rst to relnotes/vX.Y.rst
    PyVersion(version).update()
    PyNsistVersion(version).update()
    GitColaAppDataVersion(version).update()
    GitDagAppDataVersion(version).update()
    RelnotesStableVersion(version).update()
    PyProjectTomlFallbackVersion(version).update()
    os.system('git diff')

    return 0


def warn(msg):
    """Print a warning to stderr"""
    sys.stderr.write('warning: %s\n' % msg)


def num_version(version):
    """Return just the numeric parts of a version

    >>> num_version('v1.2.3')
    '1.2.3'
    """
    if version.startswith('v'):
        version = version[1:]
    return version


def tag_version(version):
    """Return the version number for a tag"""
    if not version.startswith('v'):
        version = 'v' + version
    return version


def is_section_end(txt):
    """Is this the end of an RST section?"""
    return (txt.startswith('=') and
            txt.endswith('=') and
            txt == ('=' * len(txt)))


class Version(object):

    path = ''

    def __init__(self, version):
        self.num_version = num_version(version)
        self.tag_version = tag_version(version)
        self.readonly = False

    def match(self):
        """Does the current line need replacement?"""
        return False

    def replacement(self, txt):
        """Return a replacement for the current line"""
        return txt

    def read(self):
        """Read a file into memory"""
        with open(self.path, 'r') as f:
            return f.read()

    def write(self, content):
        """Write new content to the file in the 'path' class attribute"""
        if self.readonly:
            return
        with open(self.path, 'w') as f:
            f.write(content)

    def filter(self, content):
        """Loop over the file contents and replace lines that match"""
        if not content:
            return ''
        final_content = []
        for txt in content.splitlines():
            if self.match(txt):
                final_content.append(self.replacement(txt))
            else:
                final_content.append(txt)
        return '\n'.join(final_content) + '\n'

    def update(self):
        """Main entry point for updating files"""
        if self.readonly:
            self.warn()
            return
        content = self.filter(self.read())
        self.write(content)
        self.warn()

    def warn(self):
        """Display warnings specific to the file"""
        pass


class PyVersion(Version):

    path = 'cola/_version.py'

    def match(self, txt):
        return txt.startswith('VERSION =')

    def replacement(self, txt):
        return "VERSION = '%s'" % self.num_version


class AppDataVersion(Version):
    """Append tagged versions to the *.appdata.xml files"""

    def match(self, txt):
        """Modify the file when we find the opening <releases> tag"""
        return txt.startswith('  <releases>')

    def replacement(self, txt):
        """Append a <release version=... /> xml tag to appinfo.xml """
        version = self.num_version
        now = datetime.datetime.now()
        date = now.strftime('%Y-%m-%d')
        return '%s\n    <release version="%s" date="%s" />' % (txt, version, date)


class GitColaAppDataVersion(AppDataVersion):
    """Add new releases to git-cola.appdata.xml"""

    path = 'share/metainfo/git-cola.appdata.xml'


class GitDagAppDataVersion(AppDataVersion):
    """Add new releases to git-dag.appdata.xml"""

    path = 'share/metainfo/git-dag.appdata.xml'


class PyNsistVersion(Version):
    """Update pynsist.cfg with the current version"""

    path = 'pynsist.cfg'

    def __init__(self, version):
        super(PyNsistVersion, self).__init__(version)
        self.section = ''

    def match(self, txt):
        if txt.startswith('['):
            self.section = txt[1:-1]
            return False
        return self.section == 'Application' and txt.startswith('version=')

    def replacement(self, txt):
        return 'version=%s' % self.num_version


class RelnotesStableVersion(Version):

    path = 'docs/relnotes.rst'

    def __init__(self, version):
        super(RelnotesStableVersion, self).__init__(version)
        self.last = ''
        self.section = ''

    def match(self, txt):
        if is_section_end(txt):
            self.section = self.last
            return False

        result = (self.section == 'Latest Release' and
                    txt.startswith(':ref:`v'))
        self.last = txt
        return result

    def replacement(self, txt):
        version = self.tag_version
        return (r':ref:`%s <%s>` is the latest stable release.'
                % (version, version))


class PyProjectTomlFallbackVersion(Version):

    path = 'pyproject.toml'

    def __init__(self, version):
        super(PyProjectTomlFallbackVersion, self).__init__(version)

    def match(self, txt):
        return txt.startswith('fallback_version = ')

    def replacement(self, txt):
        return 'fallback_version = "%s"' % self.num_version


if __name__ == '__main__':
    sys.exit(main())
